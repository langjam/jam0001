(** {1 Kl_IR}
    An expression language designed to be generated by the KerLang compiler
*)

(** {2 Syntax} *)

type op = OUT | ADD | MUL | DIV | SUB | FUN of string | SELF

and ast =
  | App of op * ast list
  | Cst of int
  | Var of int
  | If of ast * ast * ast

type ftable = (string * ast) list

let flookup (fname : string) (ftable : ftable) : ast =
  match List.assoc_opt fname ftable with
  | None -> raise (Kl_errors.CompileError ("unknown function " ^ fname))
  | Some x -> x

let elookup (vname : string) env =
  match List.assoc_opt vname env with
  | None -> raise (Kl_errors.CompileError ("unknown name " ^ vname ^ " in context"))
  | Some x -> x

let[@inline] show x next = App (OUT, [x; next])
let[@inline] add x y = App (ADD, [x; y])
let[@inline] sub x y = App (SUB, [x; y])
let[@inline] mul x y = App (MUL, [x; y])
let[@inline] div x y = App (DIV, [x; y])
let[@inline] app f args = App (f, args)
let[@inline] func name = FUN name

(** {3 Semantics} *)

let rec eval ?self:(self : ast option = None) (env : int list) (ftable : ftable) (expr : ast) : int =
  match expr with
  | App (op, args) ->
    List.map (eval ~self env ftable) args
    |> eval_op self ftable op
  | Cst n -> n
  | Var x -> List.nth env x
  | If (c, b1, b2) ->
    if eval ~self env ftable c = 0
    then eval ~self env ftable b2
    else eval ~self env ftable b1

and eval_op (self : ast option) ftable = function
  | OUT -> (function [x; next] -> print_int x |> print_newline; next | _ -> Kl_errors.dev_error "OUT : wrong number of args")
  | ADD -> (function [x; y] -> x + y | _ -> Kl_errors.dev_error "ADD : wrong number of args")
  | SUB -> (function [x; y] -> x - y | _ -> Kl_errors.dev_error "SUB : wrong number of args")
  | MUL -> (function [x; y] -> x * y | _ -> Kl_errors.dev_error "MUL : wrong number of args")
  | DIV -> (function [x; y] -> x / y | _ -> Kl_errors.dev_error "DIV : wrong number of args")
  | FUN fname -> (fun args ->
      let body = flookup fname ftable in
      eval ~self:(Some body) args ftable body)
  | SELF ->
    match self with
    | Some body -> fun args -> eval ~self args ftable body
    | None -> Kl_errors.dev_error "'self' is unbound"

and pp_ast fmt = function
  | App (op, args) ->
    Format.fprintf fmt "@[(%a@, @[%a@])@]" pp_op op pp_list args
  | Cst n ->
    Format.pp_print_int fmt n
  | Var x ->
    Format.fprintf fmt "x%d" x
  | If (c, e1, e2) ->
    Format.fprintf fmt "(if @[%a@]@, @[%a@]@, @[%a@])" pp_ast c pp_ast e1 pp_ast e2

and pp_op fmt = function
  | OUT -> Format.pp_print_string fmt "out"
  | ADD -> Format.pp_print_string fmt "+"
  | SUB -> Format.pp_print_string fmt "-"
  | MUL -> Format.pp_print_string fmt "Ã—"
  | DIV -> Format.pp_print_string fmt "/"
  | FUN fname -> Format.pp_print_string fmt fname
  | SELF -> Format.pp_print_string fmt "self"

and pp_list fmt = function
  | [] -> ()
  | [x] -> pp_ast fmt x
  | x::xs -> Format.fprintf fmt "%a @,%a" pp_ast x pp_list xs
let count =
  If (Var 0,
      app OUT [Var 0; app SELF [sub (Var 0) (Cst 1)]],
      app OUT [Cst 0; Cst 0])

(** {2 Utils} *)

let max3 x y z = max (max x y) z

let rec ast_count_params (func : ast): int =
  match func with
  | Cst _ -> 0
  | Var id ->
    (* The exisence of x_n tells us that there are at least (n + 1) variables. *)
    id + 1
  | App (_, args) ->
    List.fold_right (fun ast acc -> max (ast_count_params ast) acc) args 0
  | If (cond, ifcase, elsecase) ->
    max3 (ast_count_params cond) (ast_count_params ifcase) (ast_count_params elsecase)

let rec ast_is_recursive (func : ast) : bool =
  let op_is_self = function SELF -> true | _ -> false in
  match func with
  | Cst _ | Var _ -> false
  | App (op, args) ->
    if (op_is_self op) then true
    else List.exists ast_is_recursive args
  | If (cond, ifcase, elsecase) ->
    List.exists ast_is_recursive [cond; ifcase; elsecase]